# 行业中性化技术分析报告

## 📋 概述

本文档详细解释为什么Alpha101因子库中24个需要行业中性化的因子无法直接实现，以及实现行业中性化所需的技术条件。

---

## 🔍 什么是行业中性化？

### 基本概念
行业中性化（Industry Neutralization）是一种风险控制技术，目的是**消除行业因素对因子的影响**，使因子值在不同行业间具有可比性。

### 数学原理
```
原始因子 = α + β₁×行业₁ + β₂×行业₂ + ... + ε

行业中性化后 = α + ε
```

### 示例说明
假设两个股票：
- **股票A**（科技股）：PE=50，行业平均PE=45
- **股票B**（银行股）：PE=5，行业平均PE=4.5

**问题**：直接比较PE会发现股票A远高于股票B，但这主要是行业差异，而非个股特征。

**解决方案**：行业中性化后：
- 股票A：50 - 45 = +5（高于行业平均）
- 股票B：5 - 4.5 = +0.5（高于行业平均）

这样可以更公平地比较不同行业的股票。

---

## 🚫 为什么24个因子无法实现？

### 1. 缺少行业分类数据

#### 需要的数据
```python
# 每只股票需要行业分类信息
{
    'ts_code': '000001.SZ',
    'trade_date': '20240101',
    'industry': 'J66',  # 货币金融服务
    'subindustry': 'J6610',  # 货币银行服务
    'sector': 'J'  # 金融
}
```

#### 当前数据库情况
```sql
-- 查询行业分类表
SELECT * FROM industry_classification LIMIT 1;

-- 结果：表不存在或无数据
```

### 2. 缺少IndNeutralize函数

#### 聚宽的实现方式
```python
# 聚宽内置函数
def IndNeutralize(factor, industry_class):
    """
    行业中性化处理

    参数:
        factor: 因子值Series (index=股票代码)
        industry_class: 行业分类Series (index=股票代码)

    返回:
        中性化后的因子值Series
    """
    # 1. 按行业分组
    grouped = factor.groupby(industry_class)

    # 2. 计算行业均值
    industry_mean = grouped.mean()

    # 3. 减去行业均值
    result = factor - factor.groupby(industry_class).transform('mean')

    return result
```

#### 我们需要实现的
```python
def industry_neutralize(factor: pd.Series, industry: pd.Series) -> pd.Series:
    """
    行业中性化

    需要:
    1. 行业分类数据
    2. 按行业计算均值
    3. 返回残差
    """
    # 按行业计算均值
    industry_mean = factor.groupby(industry).mean()

    # 减去行业均值
    result = factor.copy()
    for ind in industry.unique():
        mask = industry == ind
        result[mask] = factor[mask] - industry_mean[ind]

    return result
```

### 3. 行业分类标准不统一

#### 不同的行业分类标准
- **证监会行业分类** (CSRC)
- **申万行业分类** (SW)
- **GICS行业分类** (全球行业分类标准)
- **中证行业分类** (CSI)

#### Alpha101使用的标准
聚宽Alpha101使用的是**申万行业分类**，包含：
- 28个一级行业
- 104个二级行业（子行业）
- 327个三级行业

### 4. 数据时效性问题

#### 行业分类会变化
```
2023年: 某公司属于"计算机行业"
2024年: 公司转型，变为"通信行业"
```

#### 需要历史行业分类
```python
# 需要的数据结构
{
    'ts_code': '000001.SZ',
    'trade_date': '20240101',
    'industry': 'J66',
    'start_date': '20200101',
    'end_date': '20241231'
}
```

---

## 📊 24个未实现因子列表

### 需要行业分类的因子

| 因子 | 公式中的行业中性化 | 所需行业层级 |
|------|-------------------|-------------|
| Alpha_048 | `IndNeutralize(..., IndClass.subindustry)` | 子行业 |
| Alpha_058 | `IndNeutralize(vwap, IndClass.sector)` | 一级行业 |
| Alpha_059 | `IndNeutralize(..., IndClass.industry)` | 二级行业 |
| Alpha_063 | `IndNeutralize(close, IndClass.industry)` | 二级行业 |
| Alpha_067 | `IndNeutralize(vwap, IndClass.sector)` | 一级行业 |
| Alpha_069 | `IndNeutralize(vwap, IndClass.industry)` | 二级行业 |
| Alpha_070 | `IndNeutralize(close, IndClass.industry)` | 二级行业 |
| Alpha_076 | `IndNeutralize(low, IndClass.sector)` | 一级行业 |
| Alpha_079 | `IndNeutralize(..., IndClass.sector)` | 一级行业 |
| Alpha_080 | `IndNeutralize(..., IndClass.industry)` | 二级行业 |
| Alpha_081 | `IndNeutralize(..., IndClass.industry)` | 二级行业 |
| Alpha_082 | `IndNeutralize(volume, IndClass.sector)` | 一级行业 |
| Alpha_087 | `IndNeutralize(..., IndClass.industry)` | 二级行业 |
| Alpha_089 | `IndNeutralize(vwap, IndClass.industry)` | 二级行业 |
| Alpha_090 | `IndNeutralize(adv40, IndClass.subindustry)` | 子行业 |
| Alpha_091 | `IndNeutralize(close, IndClass.industry)` | 二级行业 |
| Alpha_093 | `IndNeutralize(vwap, IndClass.industry)` | 二级行业 |
| Alpha_097 | `IndNeutralize(..., IndClass.industry)` | 二级行业 |
| Alpha_100 | `IndNeutralize(..., IndClass.subindustry)` | 子行业 |

### 行业分类层级说明

```
一级行业 (Sector) - 28个
├── 农、林、牧、渔业 (A)
├── 采矿业 (B)
├── 制造业 (C)
├── 电力、热力、燃气及水生产和供应业 (D)
├── 建筑业 (E)
├── 批发和零售业 (F)
├── 交通运输、仓储和邮政业 (G)
├── 住宿和餐饮业 (H)
├── 信息传输、软件和信息技术服务业 (I)
├── 金融业 (J)
├── 房地产业 (K)
├── 租赁和商务服务业 (L)
├── 科学研究和技术服务业 (M)
├── 水利、环境和公共设施管理业 (N)
├── 居民服务、修理和其他服务业 (O)
├── 教育 (P)
├── 卫生和社会工作 (Q)
├── 文化、体育和娱乐业 (R)
└── 综合 (S)

二级行业 (Industry) - 104个
三级行业 (Subindustry) - 327个
```

---

## 💡 实现行业中性化的完整方案

### 1. 数据准备

#### 需要新增的数据表
```sql
-- 行业分类表
CREATE TABLE industry_classification (
    ts_code VARCHAR(20),      -- 股票代码
    trade_date INT,           -- 日期
    industry_l1 VARCHAR(10),  -- 一级行业
    industry_l2 VARCHAR(10),  -- 二级行业
    industry_l3 VARCHAR(10),  -- 三级行业
    industry_name VARCHAR(50),-- 行业名称
    start_date INT,           -- 分类开始日期
    end_date INT,             -- 分类结束日期
    update_flag VARCHAR(1),   -- 更新标志
    PRIMARY KEY (ts_code, trade_date, industry_l1)
);

-- 示例数据
INSERT INTO industry_classification VALUES
('000001.SZ', 20240101, 'J', 'J66', 'J6610', '货币银行服务', 20200101, 99991231, '1'),
('000002.SZ', 20240101, 'K', 'K70', 'K7010', '房地产开发', 20200101, 99991231, '1');
```

### 2. 实现IndNeutralize函数

```python
class IndustryNeutralizer:
    """行业中性化处理器"""

    def __init__(self, db_connection):
        self.db = db_connection
        self.industry_cache = {}

    def get_industry_data(self, ts_codes: List[str], start_date: str, end_date: str) -> pd.DataFrame:
        """获取行业分类数据"""
        sql = """
        SELECT ts_code, trade_date, industry_l1, industry_l2, industry_l3
        FROM industry_classification
        WHERE ts_code IN (%s)
          AND trade_date >= %s
          AND trade_date <= %s
        ORDER BY ts_code, trade_date
        """ % (','.join(['%s'] * len(ts_codes)),)

        data = self.db.execute_query(sql, ts_codes + [start_date, end_date])
        return pd.DataFrame(data)

    def indneutralize(self, factor: pd.Series, industry: pd.Series, level: str = 'l2') -> pd.Series:
        """
        行业中性化

        参数:
            factor: 因子值 (index=股票代码)
            industry: 行业分类 (index=股票代码)
            level: 行业层级 ('l1', 'l2', 'l3')

        返回:
            中性化后的因子值
        """
        # 选择行业层级
        if level == 'l1':
            industry_group = industry['industry_l1']
        elif level == 'l2':
            industry_group = industry['industry_l2']
        elif level == 'l3':
            industry_group = industry['industry_l3']
        else:
            raise ValueError("level must be 'l1', 'l2', or 'l3'")

        # 按行业计算均值
        industry_mean = factor.groupby(industry_group).mean()

        # 减去行业均值
        result = factor.copy()
        for ind in industry_mean.index:
            mask = industry_group == ind
            if mask.sum() > 0:  # 确保有该行业的股票
                result[mask] = factor[mask] - industry_mean[ind]

        return result

    def neutralize_factor(self, df: pd.DataFrame, factor_name: str,
                         industry_level: str = 'l2') -> pd.Series:
        """
        对DataFrame中的因子进行行业中性化

        参数:
            df: 包含因子和行业数据的DataFrame
            factor_name: 因子列名
            industry_level: 行业层级

        返回:
            中性化后的因子Series
        """
        if factor_name not in df.columns:
            raise ValueError(f"Factor {factor_name} not found in DataFrame")

        if 'industry_l1' not in df.columns:
            raise ValueError("Industry data not found in DataFrame")

        factor = df[factor_name]
        industry = df[['industry_l1', 'industry_l2', 'industry_l3']]

        return self.indneutralize(factor, industry, industry_level)
```

### 3. 在Alpha101中集成

```python
class Alpha101CalculatorWithNeutralization(Alpha101Calculator):
    """支持行业中性化的Alpha101计算器"""

    def __init__(self, ts_codes: List[str], start_date: str, end_date: str):
        super().__init__(ts_codes, start_date, end_date)
        self.neutralizer = IndustryNeutralizer(db)
        self.load_industry_data()

    def load_industry_data(self):
        """加载行业分类数据"""
        self.industry_data = self.neutralizer.get_industry_data(
            self.ts_codes, self.start_date, self.end_date
        )

        # 合并到主数据
        if len(self.industry_data) > 0:
            self.merged_data = pd.merge(
                self.merged_data,
                self.industry_data[['ts_code', 'trade_date', 'industry_l1', 'industry_l2', 'industry_l3']],
                on=['ts_code', 'trade_date'],
                how='left'
            )

    def alpha_048(self, df: pd.DataFrame) -> pd.Series:
        """
        Alpha_048: 需要行业中性化

        公式:
        (indneutralize(((correlation(delta(close, 1), delta(delay(close, 1), 1), 250)* delta(close, 1)) / close), IndClass.subindustry) / sum(((delta(close, 1) / delay(close, 1))^2), 250))
        """
        # 1. 计算原始因子
        delta_close = self.delta(df['close'], 1)
        delta_delay = self.delta(self.delay(df['close'], 1), 1)

        corr = self.correlation(delta_close, delta_delay, 250)
        numerator = corr * delta_close / df['close']

        denominator = self.sum((delta_close / self.delay(df['close'], 1)) ** 2, 250)

        raw_factor = numerator / denominator

        # 2. 行业中性化 (子行业)
        if 'industry_l3' in df.columns:
            industry = df[['industry_l1', 'industry_l2', 'industry_l3']]
            neutralized = self.neutralizer.indneutralize(raw_factor, industry, 'l3')
            return neutralized
        else:
            print("⚠️  缺少行业数据，返回原始因子")
            return raw_factor

    def alpha_058(self, df: pd.DataFrame) -> pd.Series:
        """
        Alpha_058: 需要行业中性化 (一级行业)
        """
        # 计算原始因子
        raw_factor = self.ts_rank(
            self.decay_linear(
                self.correlation(
                    self.indneutralize(df['vwap'], df[['industry_l1', 'industry_l2', 'industry_l3']], 'l1'),
                    df['volume'],
                    3.92795
                ),
                7.89291
            ),
            5.50322
        )

        return raw_factor

    # ... 其他需要中性化的因子
```

### 4. 使用示例

```python
# 1. 创建支持中性化的计算器
calculator = Alpha101CalculatorWithNeutralization(
    ts_codes=['000001.SZ', '600519.SH'],
    start_date='20240101',
    end_date='20241231'
)

# 2. 获取数据
df = calculator.get_stock_data('000001.SZ')

# 3. 计算需要中性化的因子
alpha_048 = calculator.alpha_048(df)  # 自动行业中性化
alpha_058 = calculator.alpha_058(df)  # 自动行业中性化

# 4. 手动中性化其他因子
from factors.alpha101.alpha101_base import Alpha101Calculator

calc = Alpha101Calculator(codes, start, end)
df = calc.get_stock_data(code)

# 计算原始因子
raw_alpha_001 = calc.alpha_001(df)

# 手动行业中性化
if 'industry_l2' in df.columns:
    neutralizer = IndustryNeutralizer(db)
    neutralized_alpha_001 = neutralizer.indneutralize(
        raw_alpha_001,
        df[['industry_l1', 'industry_l2', 'industry_l3']],
        'l2'
    )
```

---

## 🎯 为什么聚宽能实现？

### 聚宽的优势
1. **完整的行业数据库** - 内置申万行业分类
2. **IndNeutralize内置函数** - 直接调用
3. **历史数据完整** - 2005年至今的行业分类

### 我们缺少的
1. ❌ 行业分类数据表
2. ❌ 行业分类历史数据
3. ❌ IndNeutralize函数实现
4. ❌ 行业数据更新机制

---

## 💰 实现成本与收益

### 实现成本
- **数据获取**: 需要申万行业分类数据（可能需要付费）
- **开发时间**: 2-3天实现完整框架
- **维护成本**: 行业数据需要定期更新

### 实现收益
- **因子完整性**: 100%因子可用
- **策略质量**: 行业中性化提高策略稳定性
- **研究价值**: 更多因子选择

---

## 📋 推荐方案

### 短期方案（当前）
- ✅ 使用77个已实现因子
- ✅ 避免使用需要行业中性化的因子
- ✅ 在策略层面进行行业中性化

### 中期方案（1个月内）
1. **获取行业数据**
   - 购买申万行业分类数据
   - 或从公开源获取（Wind、Choice等）

2. **实现基础框架**
   - IndustryNeutralizer类
   - IndNeutralize函数
   - 数据缓存机制

3. **完成24个因子**
   - 逐个实现需要中性化的因子
   - 验证计算结果

### 长期方案
- 建立行业数据自动更新机制
- 实现多种行业分类标准
- 开发行业中性化策略框架

---

## 🔗 相关资源

### 行业分类标准
- [申万行业分类标准](http://www.swsresearch.com/)
- [证监会行业分类](http://www.csrc.gov.cn/)
- [GICS行业分类](https://www.msci.com/gics)

### 数据来源
- Wind金融终端
- Choice数据终端
- Tushare Pro
- 聚宽数据API

---

## ✅ 总结

**为什么24个因子无法实现？**
1. ❌ 缺少行业分类数据
2. ❌ 缺少IndNeutralize函数
3. ❌ 缺少历史行业分类
4. ❌ 缺少行业数据维护机制

**如何解决？**
1. 获取行业分类数据
2. 实现行业中性化框架
3. 完成24个因子的实现

**当前建议：**
- 优先使用77个已实现因子
- 在策略层面进行行业中性化
- 逐步完善行业数据基础设施

---

**文档版本**: v1.0
**分析日期**: 2026-01-03
**技术难度**: 中等
**实现优先级**: 中等